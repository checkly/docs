---
title: 'API Checks Overview'
description: 'Monitor API endpoints with comprehensive HTTP request validation, performance testing, and detailed response analysis.'
sidebarTitle: 'Overview'
---
<Tip>
**Monitoring as Code**: Learn more about the [API Check Construct](/constructs/api-check).
</Tip>  

<Frame>
<img 
  className="block dark:hidden" 
  src="/images/api-check-light.png" 
  alt="Light mode interface"
/>
<img 
  className="hidden dark:block" 
  src="/images/api-check-dark.png" 
  alt="Dark mode interface"
/>
</Frame>

## What are API Checks?

API checks are automated HTTP requests that validate API endpoint functionality by checking status codes, response content, headers, and performance metrics. They simulate real API usage patterns and help catch issues before they impact your users. You can create API checks in the UI, via the [API Check Construct](/constructs/api-check) or by importing your existing Swagger/OpenAPI spec.

**API checks are perfect for:**
- REST API endpoint monitoring
- GraphQL API validation
- Authentication system testing
- Third-party API dependency monitoring
- Payment and transaction APIs

<Accordion title="Key capabilities" icon="api">
- HTTP method support (GET, POST, PUT, DELETE, etc.)
- Request/response validation
- JSON schema validation
- Authentication handling
- Performance measurement
- Global monitoring locations
</Accordion>

## How API Checks Work

API checks perform comprehensive endpoint validation:

1. **HTTP Request** - Sends configured requests with headers, body, and authentication
2. **Response Analysis** - Captures status codes, headers, body content, and timing
3. **Validation** - Runs assertions against response data and performance metrics
4. **Performance Tracking** - Measures response times and identifies trends
5. **Alert Generation** - Notifies teams when endpoints fail or degrade

<Tip>
API checks are ideal for testing both internal services and external API dependencies your application relies on.
</Tip>

## Timeouts 

All API checks are capped at a timeout of **30 seconds**. With each request, we record the most relevant timing phases. This can help you troubleshoot slow responses, e.g. your DNS might be slow.

The timing phases correspond to the Node.js request library timing phases:

- `wait`: Duration of socket initialization
- `dns`: Duration of DNS lookup
- `tcp`: Duration of TCP connection
- `firstByte`: Duration of HTTP server response
- `download`: Duration of HTTP download

![api monitoring timing phases](/docs/images/api-checks/timing-phases.png)

## Interpreting the `wait` metric  

The "wait" time is the time it takes for the underlying Node HTTP module to get a socket from the network layer. 
This time can vary quite a bit, usually it goes from 900 microseconds to some milliseconds. Most clients for API / webpage will have this lag too.

## Getting the `Error: ESOCKETTIMEDOUT` error

Sometimes API checks return this error, without any other information on what caused it. 
 
- This is a socket timeout error. Essentially there is no successful connection with the API at the TCP and/or DNS level. 
Then, Checkly is closing the connection after the usual 30 seconds timeout, because the server didnâ€™t respond. 
- Usually the root cause for this error is intermittent network issues on the application side.
- There will probably be no errors in the application logs, as it was not even possible to establish a connection.
- The response headers will be empty. If Checkly doesn't get a connection, there is nothing to send back, e.g. the response headers.




