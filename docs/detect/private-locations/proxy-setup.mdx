---
title: 'Proxy Setup'
description: 'Configure HTTP proxies for Checkly Private Locations in enterprise environments. Set up proxy routing for both agent management traffic and check execution.'
---

import { Note, Warning, Tip, Info } from 'mintlify/components'

# HTTP Proxy Configuration

Enterprise environments often require HTTP proxies for outbound internet access. Checkly Private Locations support comprehensive proxy configuration for both agent management traffic and check execution.

## Proxy Types and Use Cases

<CardGroup cols={2}>
<Card title="Agent Management Proxy" icon="gear">
Routes agent communication to Checkly's platform
- Agent authentication and registration
- Check scheduling and coordination
- Result reporting and telemetry
- Health monitoring and status updates
</Card>

<Card title="Check Execution Proxy" icon="globe">
Routes outbound traffic from checks
- API check requests to external services
- Browser check network traffic
- DNS resolution and SSL connections
- Custom application protocols
</Card>
</CardGroup>

## Agent Management Proxy Configuration

Configure proxies for agent-to-Checkly communication using environment variables:

### Basic Proxy Setup

```bash
# HTTPS proxy (recommended)
docker run \
  -e API_KEY="pl_your_api_key" \
  -e HTTPS_PROXY="https://proxy.company.com:8080" \
  -d checkly/agent:latest

# HTTP proxy (for non-HTTPS proxy servers)
docker run \
  -e API_KEY="pl_your_api_key" \
  -e HTTP_PROXY="http://proxy.company.com:8080" \
  -d checkly/agent:latest
```

### Authenticated Proxy

```bash
# Proxy with username and password
docker run \
  -e API_KEY="pl_your_api_key" \
  -e HTTPS_PROXY="https://username:password@proxy.company.com:8080" \
  -d checkly/agent:latest

# Using URL encoding for special characters
docker run \
  -e API_KEY="pl_your_api_key" \
  -e HTTPS_PROXY="https://user%40company.com:p%40ssw0rd@proxy.company.com:8080" \
  -d checkly/agent:latest
```

### Corporate Environment Example

```bash
# Complete enterprise setup
docker run \
  --name checkly-agent-corp \
  --restart unless-stopped \
  -e API_KEY="pl_corporate_key..." \
  -e HTTPS_PROXY="https://proxy-user:proxy-pass@proxy.corp.internal:3128" \
  -e JOB_CONCURRENCY=3 \
  -e LOG_LEVEL="INFO" \
  -v /etc/ssl/certs/corporate-ca.crt:/usr/local/share/ca-certificates/corporate.crt \
  -e NODE_EXTRA_CA_CERTS=/usr/local/share/ca-certificates/corporate.crt \
  -d checkly/agent:latest
```

## Check Execution Proxy Configuration

Configure proxies for the traffic generated by your checks themselves.

### Global Environment Variables

Store proxy configuration as global environment variables for reuse across checks:

![Configure global environment variables for proxy settings](/images/private-locations/proxy_private_locations_1.png)

1. Navigate to [Environment Variables](https://app.checklyhq.com/environment-variables)
2. Create a new variable (e.g., `PROXY_URL`)
3. Set the value to your proxy URL: `http://proxy.company.com:8080`

### Private Location Proxy Configuration

Apply proxy settings to your Private Location:

![Configure proxy settings for your Private Location](/images/private-locations/proxy_private_locations_2.png)

1. Edit your Private Location settings
2. Reference the environment variable: `{{PROXY_URL}}`
3. This configuration applies to all API checks and uptime monitors

<Note>
Using global environment variables allows you to easily update proxy settings across multiple Private Locations and checks without modifying individual configurations.
</Note>

## Browser Check Proxy Configuration

Browser checks require explicit proxy configuration in your Playwright test code:

<CodeGroup>
```typescript TypeScript
import { test } from '@playwright/test'

// Configure proxy for all tests in this file
test.use({
  proxy: {
    server: process.env.PROXY_URL || 'http://proxy.company.com:8080',
    username: process.env.PROXY_USERNAME,
    password: process.env.PROXY_PASSWORD
  }
})

test('Navigate with proxy', async ({ page }) => {
  await page.goto('https://example.com')
  
  // Your test steps here
  await page.waitForLoadState('networkidle')
  await expect(page.locator('h1')).toBeVisible()
})
```

```javascript JavaScript
const { test } = require('@playwright/test')

test.use({
  proxy: {
    server: process.env.PROXY_URL || 'http://proxy.company.com:8080',
    username: process.env.PROXY_USERNAME,
    password: process.env.PROXY_PASSWORD
  }
})

test('Corporate intranet access', async ({ page }) => {
  await page.goto('https://intranet.company.com')
  await page.fill('#username', 'testuser')
  await page.fill('#password', 'testpass')
  await page.click('#login')
  
  await expect(page.locator('.dashboard')).toBeVisible()
})
```
</CodeGroup>

### Advanced Browser Proxy Configuration

```typescript
import { test, chromium } from '@playwright/test'

test('Custom proxy per test', async () => {
  // Create browser with specific proxy settings
  const browser = await chromium.launch({
    proxy: {
      server: 'http://special-proxy.company.com:8080',
      username: 'special-user',
      password: 'special-pass'
    }
  })
  
  const context = await browser.newContext()
  const page = await context.newPage()
  
  await page.goto('https://secure-service.company.com')
  
  // Test logic here
  
  await browser.close()
})

test('Conditional proxy usage', async ({ page }) => {
  // Only use proxy for specific domains
  await page.route('**/*', (route) => {
    const url = route.request().url()
    
    if (url.includes('external-api.com')) {
      // Route through proxy for external calls
      route.continue()
    } else {
      // Direct connection for internal calls
      route.continue()
    }
  })
  
  await page.goto('https://internal-app.company.local')
})
```

## Proxy Authentication Methods

### Basic Authentication

```bash
# Direct credentials in URL
HTTPS_PROXY="https://username:password@proxy.company.com:8080"

# Encoded credentials for special characters
HTTPS_PROXY="https://user%40domain.com:pa%24%24word@proxy.company.com:8080"
```

### NTLM Authentication

```bash
# NTLM proxy setup (requires additional configuration)
docker run \
  -e API_KEY="pl_key..." \
  -e HTTPS_PROXY="https://domain\\username:password@proxy.company.com:8080" \
  -d checkly/agent:latest
```

### Certificate-Based Authentication

```bash
# Proxy with client certificates
docker run \
  -e API_KEY="pl_key..." \
  -e HTTPS_PROXY="https://proxy.company.com:8080" \
  -v /path/to/client.crt:/etc/ssl/certs/client.crt \
  -v /path/to/client.key:/etc/ssl/private/client.key \
  -e NODE_CLIENT_CERT_FILE=/etc/ssl/certs/client.crt \
  -e NODE_CLIENT_KEY_FILE=/etc/ssl/private/client.key \
  -d checkly/agent:latest
```

## Proxy Configuration Examples

### Multi-Tier Proxy Setup

```bash
#!/bin/bash
# multi-proxy-setup.sh

# Different proxies for different traffic types
docker run \
  --name checkly-agent-multi-proxy \
  -e API_KEY="pl_key..." \
  -e HTTPS_PROXY="https://mgmt-proxy.corp.com:8080" \
  -e CHECK_PROXY_URL="http://check-proxy.corp.com:3128" \
  -d checkly/agent:latest
```

### Proxy with Bypass Rules

Configure proxy bypass for internal domains:

```typescript
// In your browser checks
test.use({
  proxy: {
    server: process.env.PROXY_URL,
    bypass: '*.company.local,*.internal,localhost,127.0.0.1,10.*'
  }
})

test('Mixed internal and external access', async ({ page }) => {
  // This goes direct (bypasses proxy)
  await page.goto('https://internal-app.company.local')
  
  // This goes through proxy
  await page.goto('https://external-api.example.com')
})
```

### Docker Compose with Proxy

```yaml
version: '3.8'
services:
  checkly-agent:
    image: checkly/agent:latest
    container_name: checkly-agent-proxy
    restart: unless-stopped
    environment:
      - API_KEY=${CHECKLY_API_KEY}
      - HTTPS_PROXY=${CORPORATE_PROXY}
      - JOB_CONCURRENCY=3
      - LOG_LEVEL=INFO
    volumes:
      - ./certs/corporate-ca.crt:/usr/local/share/ca-certificates/corporate.crt:ro
    networks:
      - corporate-network

networks:
  corporate-network:
    driver: bridge
```

## Troubleshooting Proxy Issues

<AccordionGroup>
<Accordion title="Agent Connection Issues">
**Symptoms**: Agent fails to connect through proxy

**Diagnostic steps**:
```bash
# Test proxy connectivity from agent container
docker exec checkly-agent curl -x $HTTPS_PROXY -I https://agent.checklyhq.com

# Check proxy authentication
docker exec checkly-agent curl -x https://user:pass@proxy.com:8080 -I https://httpbin.org/ip

# Verify environment variables
docker exec checkly-agent env | grep -i proxy
```

**Common solutions**:
- Verify proxy URL format and credentials
- Check if proxy requires authentication
- Ensure proxy allows HTTPS connections to `agent.checklyhq.com`
- Verify corporate firewall rules
</Accordion>

<Accordion title="SSL/TLS Certificate Issues">
**Symptoms**: Certificate verification errors in proxy environments

**Solutions**:
```bash
# Add corporate CA certificates
docker run \
  -v /path/to/corporate-ca.crt:/usr/local/share/ca-certificates/corporate.crt \
  -e NODE_EXTRA_CA_CERTS=/usr/local/share/ca-certificates/corporate.crt \
  -e HTTPS_PROXY="https://proxy.company.com:8080" \
  -e API_KEY="pl_key..." \
  -d checkly/agent:latest

# Temporary workaround (not recommended for production)
docker run \
  -e NODE_TLS_REJECT_UNAUTHORIZED=0 \
  -e HTTPS_PROXY="https://proxy.company.com:8080" \
  -e API_KEY="pl_key..." \
  -d checkly/agent:latest
```
</Accordion>

<Accordion title="Check Execution Through Proxy">
**Symptoms**: Checks fail when routed through proxy

**Diagnostic steps**:
```bash
# Test API endpoint accessibility through proxy
curl -x http://proxy.company.com:8080 -I https://your-api.company.com/health

# Check DNS resolution through proxy
dig @proxy-dns.company.com your-service.internal

# Verify proxy allows target protocols and ports
telnet proxy.company.com 8080
```

**Common solutions**:
- Verify proxy allows target hosts and ports
- Check if proxy blocks certain HTTP methods
- Ensure proxy supports WebSocket connections (for browser checks)
- Configure proxy bypass rules for internal services
</Accordion>

<Accordion title="Browser Check Proxy Issues">
**Symptoms**: Browser checks fail with proxy configuration

**Solutions**:
```typescript
// More robust proxy configuration
test.use({
  proxy: {
    server: process.env.PROXY_URL,
    username: process.env.PROXY_USERNAME,
    password: process.env.PROXY_PASSWORD
  },
  // Ignore HTTPS errors if using corporate proxy
  ignoreHTTPSErrors: true
})

// Test proxy connectivity before main test
test.beforeEach(async ({ page }) => {
  // Verify proxy is working
  const response = await page.goto('https://httpbin.org/ip')
  expect(response?.status()).toBe(200)
})
```
</Accordion>
</AccordionGroup>

## Security Considerations

<CardGroup cols={2}>
<Card title="Credential Management" icon="key">
- Store proxy credentials in environment variables
- Use secrets management systems
- Rotate proxy passwords regularly
- Audit proxy access logs
</Card>

<Card title="Network Security" icon="shield">
- Use HTTPS proxies when possible
- Validate SSL certificates
- Implement proxy access controls
- Monitor proxy traffic patterns
</Card>

<Card title="Compliance" icon="clipboard-check">
- Log proxy usage for auditing
- Ensure data residency requirements
- Document proxy configurations
- Review security policies regularly
</Card>

<Card title="Performance" icon="gauge">
- Monitor proxy response times
- Configure appropriate timeouts
- Load balance proxy traffic
- Cache frequently accessed resources
</Card>
</CardGroup>

## Best Practices

### Proxy Configuration Management

```bash
# Use configuration files for complex setups
cat > proxy-config.env << EOF
CHECKLY_API_KEY=pl_your_key_here
HTTPS_PROXY=https://user:pass@proxy.corp.com:8080
HTTP_PROXY=http://proxy.corp.com:8080
NO_PROXY=localhost,127.0.0.1,*.corp.com,*.internal
JOB_CONCURRENCY=3
LOG_LEVEL=INFO
EOF

# Load configuration
docker run --env-file proxy-config.env -d checkly/agent:latest
```

### Proxy Health Monitoring

```bash
#!/bin/bash
# proxy-health-check.sh

PROXY_URL="http://proxy.company.com:8080"
CHECK_URL="https://httpbin.org/ip"

# Test proxy connectivity
if curl -x "$PROXY_URL" -s "$CHECK_URL" > /dev/null; then
  echo "Proxy is healthy"
  exit 0
else
  echo "Proxy is unhealthy"
  exit 1
fi
```

### Environment-Specific Configuration

```yaml
# Development environment
development:
  proxy:
    enabled: false
    
# Staging environment  
staging:
  proxy:
    enabled: true
    url: "http://staging-proxy.company.com:8080"
    
# Production environment
production:
  proxy:
    enabled: true
    url: "https://prod-proxy.company.com:8080"
    auth_required: true
```

## Next Steps

<CardGroup cols={2}>
<Card title="Kubernetes Deployment" href="/docs/getting-started/platform/private-locations/kubernetes-deployment">
Deploy Private Locations with proxy configuration on Kubernetes
</Card>

<Card title="Agent Configuration" href="/docs/getting-started/platform/private-locations/agent-configuration">
Advanced agent configuration options and environment variables
</Card>

<Card title="Scaling Guide" href="/docs/getting-started/platform/private-locations/scaling-redundancy">
Scale Private Locations with proxy considerations
</Card>

<Card title="Network Architecture" href="/guides/network-architecture">
Design network architecture for monitoring infrastructure
</Card>
</CardGroup>

<Info>
**Performance Impact**: Proxies introduce additional latency. Factor this into your check timeout configurations and performance expectations.
</Info>