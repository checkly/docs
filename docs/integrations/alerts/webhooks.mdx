---
title: 'Webhook Integrations'
description: 'Create custom webhook integrations to send Checkly alerts to any API endpoint with advanced templating and security features'
sidebarTitle: 'Webhooks'
---

Webhooks provide the most flexible way to integrate Checkly with any system that accepts HTTP requests. Create sophisticated integrations with custom endpoints using templating, conditional logic, and security features.

## Basic Webhook Setup

<Steps>
<Step title="Create Webhook Channel">
Navigate to Alert Settings and choose Webhook as your channel type
</Step>

<Step title="Configure Endpoint">
Set your webhook URL, HTTP method, and authentication headers
</Step>

<Step title="Customize Payload">
Design your request body using Checkly's templating system
</Step>

<Step title="Test Integration">
Send test alerts to verify your webhook integration works correctly
</Step>
</Steps>

## Advanced Webhook Configuration

Create sophisticated integrations with custom endpoints:

```json
{
  "name": "Custom Incident Management",
  "url": "https://api.internal-system.com/webhooks/checkly",
  "method": "POST",
  "headers": {
    "Authorization": "Bearer {{API_TOKEN}}",
    "Content-Type": "application/json",
    "X-Source": "checkly-monitoring",
    "X-Environment": "{{#contains CHECK_NAME 'staging'}}staging{{else}}production{{/contains}}"
  },
  "body": {
    "timestamp": "{{STARTED_AT}}",
    "event_type": "{{ALERT_TYPE}}",
    "severity": "{{#eq ALERT_TYPE 'ALERT_FAILURE'}}high{{else}}{{#eq ALERT_TYPE 'ALERT_DEGRADED'}}medium{{else}}low{{/eq}}{{/eq}}",
    "service": {
      "name": "{{CHECK_NAME}}",
      "id": "{{CHECK_ID}}",
      "type": "{{CHECK_TYPE}}",
      "tags": [{{#each TAGS}}"{{this}}"{{#unless @last}},{{/unless}}{{/each}}]
    },
    "incident": {
      "title": "{{ALERT_TITLE}}",
      "description": "Check failed from {{RUN_LOCATION}} with {{RESPONSE_TIME}}ms response time",
      "url": "{{RESULT_LINK}}",
      "location": "{{RUN_LOCATION}}",
      "response_time": {{RESPONSE_TIME}},
      "error_message": "{{CHECK_ERROR_MESSAGE}}"
    }
  }
}
```

## Template Variables

Use dynamic variables to create contextual alerts:

| Variable | Description | Example Value |
|----------|-------------|---------------|
| `CHECK_NAME` | Full check name | "Payment API Health Check" |
| `CHECK_ID` | UUID of the check | "abc123-def456-ghi789" |
| `CHECK_TYPE` | Type of check | "API", "BROWSER", "HEARTBEAT" |
| `ALERT_TITLE` | Human-readable alert title | "Check 'Payment API' has failed" |
| `ALERT_TYPE` | Alert event type | "ALERT_FAILURE", "ALERT_RECOVERY" |
| `CHECK_RESULT_ID` | UUID of the result | "result-123-456" |
| `CHECK_ERROR_MESSAGE` | Error details | "Connection timeout after 5000ms" |
| `RESPONSE_TIME` | Response time in milliseconds | 1234 |
| `RUN_LOCATION` | Location where check ran | "N. Virginia" |
| `RESULT_LINK` | Direct link to results | "https://app.checklyhq.com/..." |
| `STARTED_AT` | ISO timestamp | "2024-01-15T14:30:22.000Z" |
| `TAGS` | Array of check tags | ["critical", "payment", "api"] |
| `GROUP_NAME` | Group name if applicable | "Payment Services" |

## Handlebars Helpers and Conditional Logic

Create dynamic webhook content with conditional formatting:

```json
{
  "priority": "{{#eq ALERT_TYPE 'ALERT_FAILURE'}}P1{{else}}{{#eq ALERT_TYPE 'ALERT_DEGRADED'}}P2{{else}}P3{{/eq}}{{/eq}}",
  "environment": "{{#contains CHECK_NAME 'prod'}}production{{else}}{{#contains CHECK_NAME 'staging'}}staging{{else}}development{{/contains}}{{/contains}}",
  "escalation_needed": {{#and (eq ALERT_TYPE 'ALERT_FAILURE') (contains TAGS 'critical')}}true{{else}}false{{/and}},
  "formatted_tags": [{{#each TAGS}}"{{uppercase this}}"{{#unless @last}},{{/unless}}{{/each}}],
  "response_time_category": "{{#gt RESPONSE_TIME 5000}}slow{{else}}{{#gt RESPONSE_TIME 2000}}medium{{else}}fast{{/gt}}{{/gt}}",
  "alert_color": "{{#eq ALERT_TYPE 'ALERT_FAILURE'}}#ff0000{{else}}{{#eq ALERT_TYPE 'ALERT_DEGRADED'}}#ffa500{{else}}#00ff00{{/eq}}{{/eq}}"
}
```

## Webhook Security and Authentication

### Signature Verification

Implement secure webhook delivery with signature verification:

```javascript
const crypto = require('crypto')

function verifyChecklyWebhook(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex')
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  )
}

// Express.js webhook endpoint
app.post('/checkly-webhook', express.raw({type: 'application/json'}), (req, res) => {
  const signature = req.headers['x-checkly-signature']
  const timestamp = req.headers['x-checkly-timestamp']
  
  // Verify signature
  if (!verifyChecklyWebhook(req.body, signature, process.env.WEBHOOK_SECRET)) {
    return res.status(401).send('Invalid signature')
  }
  
  // Check timestamp to prevent replay attacks
  const webhookTimestamp = parseInt(timestamp)
  const currentTime = Math.floor(Date.now() / 1000)
  
  if (Math.abs(currentTime - webhookTimestamp) > 300) { // 5 minutes
    return res.status(401).send('Timestamp too old')
  }
  
  // Process webhook
  const alertData = JSON.parse(req.body)
  handleChecklyAlert(alertData)
  
  res.status(200).send('OK')
})
```

### Webhook Retry Logic

Checkly automatically retries failed webhooks:

```yaml
Webhook Retry Behavior:
  Max Retries: 5
  Retry Trigger: HTTP status >= 400
  Backoff Strategy: 20 seconds between retries
  Total Retry Duration: 100 seconds (5 Ã— 20s)
  
Timestamp Header: x-checkly-timestamp
Purpose: Handle late arrivals due to retries
```

## Third-Party Integration Examples

### Jira Issue Creation

Automatically create Jira tickets for check failures:

```json
{
  "fields": {
    "project": {
      "key": "OPS"
    },
    "summary": "{{ALERT_TITLE}}",
    "description": {
      "version": 1,
      "type": "doc",
      "content": [
        {
          "type": "paragraph",
          "content": [
            {
              "type": "text",
              "text": "Check Details:\n\nName: {{CHECK_NAME}}\nLocation: {{RUN_LOCATION}}\nResponse Time: {{RESPONSE_TIME}}ms\nError: {{CHECK_ERROR_MESSAGE}}\n\n"
            },
            {
              "type": "text",
              "text": "View results: ",
              "marks": [
                {
                  "type": "link",
                  "attrs": {
                    "href": "{{RESULT_LINK}}"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    "issuetype": {
      "id": "10001"
    },
    "priority": {
      "id": "{{#contains TAGS 'critical'}}1{{else}}3{{/contains}}"
    },
    "labels": [
      "checkly",
      "monitoring",
      "{{#each TAGS}}{{this}}{{#unless @last}},{{/unless}}{{/each}}"
    ]
  }
}
```

### Trello Card Creation

Create Trello cards for incident tracking:

```text
URL: https://api.trello.com/1/cards?key={{TRELLO_KEY}}&token={{TRELLO_TOKEN}}

Parameters:
- idList: {{TRELLO_LIST_ID}}
- name: {{ALERT_TITLE}}
- desc: Check {{CHECK_NAME}} failed from {{RUN_LOCATION}} at {{STARTED_AT}}. Response time: {{RESPONSE_TIME}}ms. View details: {{RESULT_LINK}}
- due: {{#eq ALERT_TYPE 'ALERT_FAILURE'}}{{addDays STARTED_AT 1}}{{/eq}}
- labels: red (for failures), orange (for degraded)
```

## Webhook Best Practices

- **Authentication**: Always use proper authentication (API keys, signatures, OAuth)
- **Idempotency**: Design endpoints to handle duplicate webhook deliveries gracefully
- **Error Handling**: Return appropriate HTTP status codes (200-299 for success, 4xx/5xx for errors)
- **Timeout**: Respond to webhooks quickly (within 30 seconds) to avoid retries
- **Logging**: Log webhook events for debugging and monitoring
- **Security**: Validate webhook signatures and implement replay attack protection