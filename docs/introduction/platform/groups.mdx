---
title: 'Groups'
description: 'Organize your checks and apply shared configuration with Groups'
sidebarTitle: 'Groups'
---

Groups help you organize your checks (e.g. by team or feature) and apply shared configuration such as API defaults, scheduling & location overrides, and other properties.

![Check group screenshot](/images/docs/images/groups/group-in-dashboard.png)

Groups serve multiple purposes: they act as organizational folders, configuration templates, and execution units. Think of them as the filing system for your monitoring infrastructure that transforms scattered checks into a coherent system reflecting your application architecture and team responsibilities.

You can populate a group by moving existing checks into it or by creating new checks directly within the group.

<Note>By default, newly created check groups behave like folders, with no group-level configuration applied. To get started:</Note>

## Configuration

Groups let you apply shared configuration to standardize how checks behave. Group-level configurations override check-level settings when applied.

### Check Membership
**Moving a check into a group:** If the group has group-level configuration defined, adding a check may change how it runs. Settings like API defaults, locations & scheduling, or retries & alerting can override the check's configuration.

**Removing check from group:** Any group-level configuration will no longer apply, and the check will use its own configuration going forward.

<Warning>
To prevent issues (e.g. broken references to group variables), the check will be automatically deactivated after being added to or removed from a group. Make sure to review its settings before reactivating.
</Warning>

### API Check Defaults
Define common base URLs, request information, assertions, and setup & teardown scripts to manage API checks in your group at scale. This eliminates repetitive configuration across similar API checks.


### Variables
You can set both variables and secrets for a Group of checks.

For browser and multistep checks, you can set variables at the check level. See [browser check variables and secrets](/docs/browser-checks/variables) for more details.

<Note>Secrets are fully supported starting with runtime version 2024.09 and later. For [Private Locations](/docs/private-locations/), secrets are available in agent version `3.3.4` and later, and for the [CLI](/docs/cli/), in version `4.9.0` and later.</Note>

#### Variable hierarchy

As checks are scheduled, Checkly merges the check, group and global environment variables into one data set and exposes them
to the runtime environment. During merging, any check variable with the same name as a global or group variable **overrides that variable.**  

Or, in other words: **check** variables trump **group** variables trump **global** variables.  

You can make use of this by providing a default value for a specific variable at the global or group level, but allow 
that variable to be overridden at the group level or check level.

### Scheduling & Locations
- **Locations:** Override location settings for all checks in the group with selected public or private locations
- **Scheduling strategy:** Override scheduling strategy (parallel, round-robin) for all checks in the group  
- **Frequency:** Set a default scheduling interval for new checks created in the group

### Retries & Alerting
- **Retries:** Configure retry strategy for failed checks (fixed, linear, exponential)
- **Alert settings:** Set up alert channels for the group - email, SMS, Slack, webhooks, etc.


### Testing & Runtimes
- **Testing:** Run checks in this group as E2E tests locally or from CI/CD pipelines
- **Runtimes:** Set the JavaScript runtime environment for browser checks and scripts if different from account default





## How Grouped Checks Execute

Understanding how grouped checks run is important for sophisticated monitoring setups:

1. **Individual scheduling:** Checks are scheduled as individual checks, not "as a group"
2. **Group triggers:** Calling a "group run" using CLI or GitHub integration runs all checks in the group
3. **No group state:** The group itself does not have an explicit runtime state
4. **Individual results:** No results or metrics are collected at the group level
5. **Independent timing:** Checks in a group maintain their individual scheduling settings

Groups are primarily configuration containers that provide shared settings and organizational structure. This approach ensures flexibility while enabling powerful configuration management at scale.

## Flexible Configuration Strategy

Groups can serve different organizational needs:

- **Strict templates:** Enforce consistency through shared configurations
- **Loose containers:** Provide structure without imposing shared settings
- **Team boundaries:** Enable clear ownership and delegation of monitoring responsibilities
- **Scaling mechanism:** Manage complexity through logical decomposition as your infrastructure grows